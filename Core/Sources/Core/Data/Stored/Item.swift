import Foundation
import Combine
import GRDB

/// A storable type that represents an item
public struct Item: Storable {
	/// A globally unique id.
	///
	/// Generated by combining `guid` with the source of the ``Feed`` and calculateing a stable hash value
	/// The type required to be `Int64` for `ValueObservation` to work correctly
	public let id: Int64
	/// Source of the ``Feed`` this item belongs to
	public let source: URL
	/// Title of the item with fallback to guid
	public let title: String
	/// Last time article was changed or published
	public let time: TimeInterval?
	/// Author of the item - multiple authors are concatinated in a comma separated list
	public let author: String?
	/// Plaintext or HTML content
	public let content: String?
	/// URL That points to ``Item``'s content. Used for extracting articles
	public let url: URL?
	/// Can be mofified by the user and is synced
	public var isRead: Bool = false
	/// Can be mofified by the user and is synced
	public var isStarred: Bool = false
	/// Sync contains archived `CKRecord`, which needs to be persisted inorder to compare upload times
	public var sync: Data?
	/// The content extracted from ``Item``'s url
	public var extracted: String?
}

extension Item {
	public enum Column: String, Sendable {
		case id, source, title, time, author, content, url,
			 isRead, isStarred, sync, extracted
		var column: GRDB.Column { GRDB.Column(self.rawValue) }
	}
}

extension Item {
	public static func publisherIDs(in store: Store, filter: Filter) -> AnyPublisher<Array<Int64>, Error> {
		ValueObservation.tracking {
			try Row
				.fetchAll($0, filter.items.order(Column.time.column.desc))
				.map { $0[Column.id.rawValue] }
		}
		.publisher(in: store.queue, scheduling: .immediate)
		.eraseToAnyPublisher()
	}
	
	public static func publisherCount(in store: Store, filter: Filter) -> AnyPublisher<Int, Error> {
		ValueObservation.tracking(filter.items.fetchCount)
			.publisher(in: store.queue, scheduling: .immediate)
			.removeDuplicates()
			.throttle(for: .seconds(1), scheduler: DispatchQueue.main, latest: true)
			.eraseToAnyPublisher()
	}
	
	public static func publisherSingle(in store: Store, for id: Item.ID) -> AnyPublisher<Item?, Error> {
		ValueObservation.tracking(Item.filter(key: id).fetchOne)
			.publisher(in: store.queue, scheduling: .immediate)
			.eraseToAnyPublisher()
	}
	
	public static func publisherRedacted(in store: Store, for id: Item.ID) -> AnyPublisher<Item?, Error> {
		ValueObservation.tracking { database in
			try Row
				.fetchOne(
					database,
					Item.select(
						Array<Column>([
							.id, .source, .title, .time, .author, .url, .isRead, .isStarred
						]).map { $0.column }
					).filter(key: id)
				)
				.map {
					Item(
						id: $0[Column.id.rawValue],
						source: $0[Column.source.rawValue],
						title: $0[Column.title.rawValue],
						time: $0[Column.time.rawValue],
						author: $0[Column.author.rawValue],
						content: nil, // Redacted
						url: $0[Column.url.rawValue],
						isRead: $0[Column.isRead.rawValue],
						isStarred: $0[Column.isStarred.rawValue],
						sync: nil, // Redacted
						extracted: nil // Redacted
					)
				}
		}
		.publisher(in: store.queue, scheduling: .immediate)
		.eraseToAnyPublisher()
	}
}
